Службы
======

Silex это не только микрофреймворк. Это также контейнер микро-служб. Эта возможность реализуется через крохотное расширение `Pimple <http://pimple.sensiolabs.org>`_.

Внедрение зависимостей
----------------------

.. note::

    Вы можете пропустить этот раздел, если уже знаете что такое "внедрение зависимостей".

Инъекция зависимостей это шаблон проектирования, где вы передаёте зависимости в службы вместо создания их в самих службах или использования глобальных данных. Как правило, это позволяет создавать отдельный, гибкий, отлично тестируемый и повторно используемый код.

Ниже приведён пример класса, который принимает объект ``User`` и сохраняет его в файле в формате JSON::

    class JsonUserPersister
    {
        private $basePath;

        public function __construct($basePath)
        {
            $this->basePath = $basePath;
        }

        public function persist(User $user)
        {
            $data = $user->getAttributes();
            $json = json_encode($data);
            $filename = $this->basePath.'/'.$user->id.'.json';
            file_put_contents($filename, $json, LOCK_EX);
        }
    }

В этом простом примере зависимостью является свойство ``basePath``. Оно передаётся в конструктор. Это означает, что вы можете создать несколько не зависящих друг от друга экземпляров с различными базовыми путями. Конечно, зависимостями могут являться не только простые строки. Чаще всего они являются другими службами.

Контейнер
~~~~~~~~~

DIC или контейнер служб отвечает за создание и хранение служб.
Он может рекурсивно создавать зависимости запрошенных служб и внедрять их.
Однако он ленив, и создаёт службы лишь тогда, когда вы нуждаетесь в них.

Большинство контейнеров являются довольно сложными и конфигурируются через XML или YAML файлы.

Pimple не такой.

Pimple
------

Pimple возможно является самым простым контейнером служб.
Он силён благодаря использованию замыканий и реализует интерфейс ArrayAccess.

Мы начнём с создания экземпляра Pimple -- и так как ``Silex\Application`` расширяет ``Pimple``, всё нижесказанное применимо и к Silex::

    $container = new Pimple();

или::

    $app = new Silex\Application();

Параметры
~~~~~~~~~

Вы можете задавать параметры (которые обычно являются строками) устанавливая их через ключи массива контейнера::

    $app['some_parameter'] = 'value';

Ключи массива могут быть любыми, по соглашению точки используются для указания пространства имён::

    $app['asset.host'] = 'http://cdn.mysite.com/';

Чтение значений параметров выполняется в аналогичном синтаксисе::

    echo $app['some_parameter'];

Определение службы
~~~~~~~~~~~~~~~~~~

Определение службы не отличается от определения параметра. Вы просто связываете ключ массива контейнера с замыканием. Однако, когда вы запросите службу вызовется замыкание. Это позволяет сделать "ленивое" создание служб::

    $app['some_service'] = function () {
        return new Service();
    };

И для получения службы используйте::

    $service = $app['some_service'];

Каждый раз при вызове ``$app['some_service']`` создаётся экземпляр службы.

Общие службы
~~~~~~~~~~~~

Вам может потребоваться использовать один и тот же экземпляр службы во всех частях своего кода.
Для реализации этого, сделайте *общую* службу::

    $app['some_service'] = $app->share(function () {
        return new Service();
    });

Этот код создаёт службу при первом вызове, а при последующих обращениях возвращает сеществующий экземпляр.

Доступ к контейнеру из замыкания
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Во множестве случаев вам может потребоваться доступ к контейнеру служб из определяющего службу замыкания. Например, когда надо получить службы, от которых зависит текущая.

Для этого контейнер передаётся в замыкание в качестве аргумента::

    $app['some_service'] = function ($app) {
        return new Service($app['some_other_service'], $app['some_service.config']);
    };

Здесь вы видите пример внедрения зависимостей. ``some_service`` зависит от ``some_other_service`` и принимает ``some_service.config`` в качестве параметров конфигурации. Зависимость создаётся только при доступе к ``some_service``, и можно заменить любую из зависимостей, просто переопределив их определения.

.. note::

    Это также работает для общих служб.

Защищённые замыкания
~~~~~~~~~~~~~~~~~~~~

Поскольку контейнер видит замыкания как фабрики для служб, он всегда исполняет их при чтении.

Однако, в некоторых случаях вам может сохранить замыкание как параметр, чтобы вы сами могли получить его исполнить со своими собственными аргументами.

Это можно сделать в Pimple при помощи метода ``protect``::

    $app['closure_parameter'] = $app->protect(function ($a, $b) {
        return $a + $b;
    });

    // замыкание не исполняется
    $add = $app['closure_parameter'];

    // теперь вызовем его
    echo $add(2, 3);

Обратите внимание, защищённые замыкания не получают доступа к контейнеру.

Основные службы
---------------

Silex определяет набор служб, которые можно использовать или переопределить. Вполне возможно, что большинством вы не пожелаете возиться.

* **request**: Содержит текущий объект запроса, являющийся экземпляром `Request <http://api.symfony.com/master/Symfony/Component/HttpFoundation/Request.html>`_. Он даёт вам доступ к параметрам ``GET``, ``POST`` и некоторым другим!

  Пример использования::

    $id = $app['request']->get('id');

  This is only available when a request is being served, you can only access
  it from within a controller, an application before/after middlewares, or an
  error handler.

* **routes**: `RouteCollection <http://api.symfony.com/master/Symfony/Component/Routing/RouteCollection.html>`_, который используется внутренними процедурами. Вы можете добавлять, изменять и читать маршруты.

* **controllers**: ``Silex\ControllerCollection``, который используется внутренними процедурами. Для подробностей смотри главу *Internals*.

* **dispatcher**: `EventDispatcher <http://api.symfony.com/master/Symfony/Component/EventDispatcher/EventDispatcher.html>`_, который используется внутренними процедурами. Является ядром Symfony2, а также используется Silex.

* **resolver**: `ControllerResolver <http://api.symfony.com/master/Symfony/Component/HttpKernel/Controller/ControllerResolver.html>`_, который используется внутренними процедурами. Заботится о выполнении контроллера с правильными аргументами.

* **kernel**: `HttpKernel <http://api.symfony.com/master/Symfony/Component/HttpKernel/HttpKernel.html>`_, который используется внутренними процедурами. HttpKernel -- это сердце Symfony2, на входе получает Request и возвращает Response на выходе.

* **request_context**: Контекст запроса -- это упрощённое представление запроса, которое используется Router и UrlGenerator.

* **exception_handler**: Обработчик исключаний по умолчанию, который используется когда вы не зарегистрировали ни одного своего через вызов метода ``error()`` или если ваш обработчик не возвращает Response. Отключается с помощъю ``$app['exception_handler']->disable()``.

* **logger**: Экземпляр `LoggerInterface <http://api.symfony.com/master/Symfony/Component/HttpKernel/Log/LoggerInterface.html>`_. По умолчанию, логирование отключается установкой значения ``null``. Если установлена связка Symfony2 - Monolog, то в качестве логгера по умолчанию используется Monolog.

.. note::

    Все эти основные службы Silex являются общими.

Основные параметры
------------------

* **request.http_port** (опциональный): Позволяет вам переопределить порт по умолчанию для не-HTTPS URL'ов. Если текущий запрос является HTTP, всегда используется текущий порт.

  Значение по умолчанию 80.

  Этот параметр используется ``UrlGeneratorProvider``.

* **request.https_port** (опциональный): Позволяет вам переопределить порт по умолчанию для HTTPS URL'ов. Если текущий запрос является HTTPS, всегда используется текущий порт.

  Значение по умолчанию 443.

  Этот параметр используется ``UrlGeneratorProvider``.

* **locale** (опциональный): Локаль пользователя. Когда установлено перед обработкой любого запроса, определяет исходную локаль (``en`` по умолчанию). При обработке запроса автоматически устанавливается соответственно атрибуту запроса ``_locale`` текущего маршрута.

* **debug** (опциональный): Возвращает истину, если приложение запущено в отладочном режиме.

  Значение по умолчанию ``false``.

* **charset** (опциональный): Набор символов используемый для ответов.

  Значение по умолчанию UTF-8.
